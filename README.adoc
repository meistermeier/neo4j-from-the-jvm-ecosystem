= Neo4j from the JVM ecosystem.

Examples of how to connect to Neo4j on the JVM, reading and writing data.

The idea of this project is to show how to access the standard movie graph and create a web api for it on different platforms running on the JVM.

All projects have been created either via their official "starter" services or Maven archetypes. 

NOTE: The order in which the frameworks is alphabetical and doesn't represent any preference.
      As I prefer Maven, I chose to create all projects as Maven projects.

https://github.com/spring-projects/spring-data-neo4j[Spring Data Neo4j 6] can be used inside a CDI container as well and is known to work in Liberty and Helidon.
We provide a CDI extension for that. You need to bring in an application scoped instance of the Neo4j Driver.
The portable CDI extension https://quarkus.io/blog/quarkus-dependency-injection/#extension-points[won't work in Quarkus].
So in case you really want to have great Object Mapping but cannot decide to use Spring as a container, 
you might want to try out the CDI extension.

Neo4j-OGM can work on GraalVM native since version 3.2.19 when you provide an index of the node entities.
The index must be in `META-INF/resources/name/of/your/package/neo4j-ogm.index`.
Also the entities in question must be registered for reflection (either through pure GraalVM `reflection-config.json` or through the means of your selected framework.)

The goal of this repository is to check and demonstrate what is necessary to achieve the following inside the current Java application frameworks and runtimes:

* Support a couple of "standard" use cases presented as HTTP Api, transporting JSON. This is a hard requirement
* See if they provide automatic setup of the Neo4j driver or at least a dynamic configuration mechanism to do this
* Check if there's an officially supported Data Mapping framework available for Neo4j.
  Having a data mapping framework layer is really nice to have, but if this is not possible, the Neo4j Java driver
  plays very well with custom mapping functions or things like https://mapstruct.org[MapStruct].
* Built-in dev-mode with reload / restart feature
* Dedicated support for optimized docker images (Preferable via the chosen build tool but a two step process via a dedicated docker file is ok)
* See if a Reactive Streams implementation is present and whether it works with the Neo4j Java driver
* See if the application can be turned into a GraalVM native image via the chosen build tool without
  fiddling around with `native-image` parameters

A red cross doesn't mean a given Framework is bad in anyway.
It is just an indicator that something either doesn't work without additional configuration or programming or is just not there.
An assessment whether a particular thing is needed or not is up to the reader and must be reasoned about in the context of the framework and it's actually present features.

All the frameworks used and tested here support the actual "business" logic.

== Shared Api

All projects provide the following API:

=== `POST /api/people`

[source,bash]
.Example request
----
$ curl 'http://localhost:8080/api/people' -i -X POST \
    -H 'Content-Type: application/json' \
    -d '{"name":"Lieschen Müller","born":2020}'
----

[source,http,options="nowrap"]
.Example response
----
HTTP/1.1 201 Created
Content-Type: application/json
Content-Length: 64

{
  "born" : 2020,
  "name" : "Lieschen Müller",
  "id" : 339
}
----

=== `GET /api/movies`

[source,bash]
.Example request
----
$ curl 'http://localhost:8080/api/movies' -i -X GET
----

[source,http,options="nowrap"]
.Example response
----
HTTP/1.1 200 OK
transfer-encoding: chunked
Content-Type: text/event-stream;charset=UTF-8
Content-Length: 1270

[ {
  "title" : "A Few Good Men",
  "description" : "In the heart of the nation's capital, in a courthouse of the U.S. government, one man will stop at nothing to keep his honor, and one will stop at nothing to find the truth.",
  "actors" : [ {
    "roles" : [ "Capt. Jack Ross" ],
    "name" : "Kevin Bacon"
  }, {
    "roles" : [ "Lt. Cdr. JoAnne Galloway" ],
    "name" : "Demi Moore"
  }, {
    "roles" : [ "Man in Bar" ],
    "name" : "Aaron Sorkin"
  }, {
    "roles" : [ "Lt. Col. Matthew Andrew Markinson" ],
    "name" : "J.T. Walsh"
  }, {
    "roles" : [ "Lt. Jonathan Kendrick" ],
    "name" : "Kiefer Sutherland"
  }, {
    "roles" : [ "Lt. Sam Weinberg" ],
    "name" : "Kevin Pollak"
  }, {
    "roles" : [ "Cpl. Jeffrey Barnes" ],
    "name" : "Noah Wyle"
  }, {
    "roles" : [ "Cpl. Carl Hammaker" ],
    "name" : "Cuba Gooding Jr."
  }, {
    "roles" : [ "Dr. Stone" ],
    "name" : "Christopher Guest"
  }, {
    "roles" : [ "Lt. Daniel Kaffee" ],
    "name" : "Tom Cruise"
  }, {
    "roles" : [ "Col. Nathan R. Jessup" ],
    "name" : "Jack Nicholson"
  }, {
    "roles" : [ "Pfc. Louden Downey" ],
    "name" : "James Marshall"
  } ],
  "directors" : [ {
    "born" : 1947,
    "name" : "Rob Reiner",
    "id" : 194
  } ],
  "released" : 1992
} ]
----

=== Status / Health checks

==== Liveness

General Liveness of the application:

[quote,Spring Boot Documentation]
____
The “Liveness” state of an application tells whether its internal state allows it to work correctly, or recover by itself if it’s currently failing.
____

[source,bash]
.Example request
----
$ curl 'http://localhost:8080/management/health/liveness' -i -X GET
----

[source,http,options="nowrap"]
.Example response
----
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Date: Mon, 16 Nov 2020 12:51:24 GMT
Content-Length: 21

{
  "status" : "UP"
}
----

==== Readiness

[quote,Spring Boot Documentation]
____
The “Readiness” state of an application tells whether the application is ready to handle traffic. A failing “Readiness” state tells the platform that it should not route traffic to the application for now.
____

We expect the Neo4j database connection to be taken into consideration for readiness.

[source,bash]
.Example Request
----
$ curl 'http://localhost:8080/management/health/readiness' -i -X GET \
    -H 'Accept: application/json'
----

[source,http,options="nowrap"]
.Example response
----
HTTP/1.1 200 OK
Content-Type: application/json
Transfer-Encoding: chunked
Date: Mon, 16 Nov 2020 12:54:29 GMT
Content-Length: 21

{
  "status" : "UP"
}
----

== Helidon SE

* ❌ Automatic setup of the Neo4j driver (A configuration framework however is provided)
* ⚠️ Officially supported Data Mapping framework available (https://github.com/neo4j/neo4j-ogm[Neo4j-OGM] can be used outside a Spring environment and can use the Driver as is, without CDI.)
* ❌ Built-in dev-mode with reload / restart feature
* ⚠️ Dedicated support for optimized docker images (A Docker file is provided)
* ✅ Reactive Streams: Helidon's own implementation
* ✅ GraalVM native compilation
* ✅ Health (Liveness, Readiness and detailed status)

Demo projects provided:

* helidon-se-reactive

Created via `mvn -U archetype:generate -DinteractiveMode=false -DarchetypeGroupId=io.helidon.archetypes-DarchetypeArtifactId=helidon-quickstart-se -DarchetypeVersion=2.1.0`,
version tested *2.1.0*.

Run with

[source,console]
----
mvn clean package
java -jar target/helidon-se-reactive.jar 
----

=== Create docker images

Two steps required, a `Dockerfile` is provided.

[source,console]
----
mvn clean package
docker build .
----

=== Create native images

----
# For your current system, GraalVM 11 is required
mvn clean package -Pnative-image
# As a native docker image
mvn clean package
docker build -f Dockerfile.native .
----

Helidon offers `io.helidon.common.Reflected` for classes that needs to be included in the image and require reflection based access.

=== Health

Health infrastructure provided with Helidon Health Checks `io.helidon.health:helidon-health` and `io.helidon.health:helidon-health-checks`, Neo4j not yet included ootb.
Configuration is done programmatically.

(Suggested) Format of the individual Neo4j status:

[source,bash]
.Request
----
$ curl 'http://localhost:8080/management/health/readiness' -i -X GET
----

[source,json]
----
{
  "outcome": "UP",
  "status": "UP",
  "checks": [
    {
      "name": "neo4j",
      "state": "UP",
      "status": "UP",
      "data": {
        "database": "neo4j",
        "edition": "enterprise",
        "server": "Neo4j/4.1.0@localhost:7687"
      }
    }
  ]
}
----

== Micronaut

* ✅ Automatic setup of the Neo4j driver
* ⚠️ Officially supported Data Mapping framework available (GORM, in beta for Neo4j, SDN 6 might work as well)
* ✅ Built-in dev-mode with reload / restart feature
* ⚠️ Dedicated support for optimized docker images (A Docker file is provided)
* ✅ Reactive Streams: https://github.com/ReactiveX/RxJava[RxJava2 and 3]
* ⚠️ GraalVM native compilation (Without additional setup only for Gradle, therefor not tested here)
* ✅ Health (Liveness, Readiness and detailed status)

Demo projects provided:

* micronaut-reactive

Created via: https://micronaut.io/launch/, version tested *2.1.3*.

=== Configuration of the Neo4j Java Driver

Support of the some 4.0.x config options under the namespace `neo4j.*`
Basic setup:

[source,yaml]
----
neo4j:
  username: neo4j
  password: secret
  uri: bolt://localhost:7687
----

=== Running

[source,console]
----
./mvnw mn:run
----

=== Create docker images

Two steps required, a `Dockerfile` is provided.

[source,console]
----
./mvnw clean package
docker build .
----

=== Create native images

Additional setup or Gradle is required.

=== Health

Health infrastructure provided with Micronaut Management (`io.micronaut:micronaut-management`), *Neo4j included ootb*.

NOTE: Path to individual endpoints for `liveness` and `readiness` seems not to be changeable.

Format of the individual Neo4j status:

[source,bash]
.Request
----
$ curl 'http://localhost:8080/management/health' -i -X GET
----

[source,json]
----
{
  "name": "micronaut-reactive",
  "status": "UP",
  "details": {
    "neo4j": {
      "name": "micronaut-reactive",
      "status": "UP",
      "details": {
        "server": "Neo4j/4.1.0@localhost:7687"
      }
    }
  }
}
----

== Quarkus

* ✅ Automatic setup of the Neo4j driver
* ⚠️ Officially supported Data Mapping framework available (https://github.com/neo4j/neo4j-ogm[Neo4j-OGM] works in JVM and dev mode and can make use of the Neo4j extension, see `quarkus-ogm` example)
* ✅ Built-in dev-mode with reload / restart feature
* ✅ Dedicated support for optimized docker images
* ✅ Reactive Streams: https://smallrye.io/smallrye-mutiny/[Smallrye Mutiny]
* ✅ GraalVM native compilation
* ✅ Health (Liveness, Readiness and detailed status)

Demo projects provided:

* quarkus-imperative
* quarkus-reactive

Created via: https://code.quarkus.io, version tested: *1.9.2.Final*.

=== Configuration of the Neo4j Java Driver

Support of the all relevant 4.1.x config options under the namespace `quarkus.neo4j.*`, including TLS:
Basic setup:

[source,properties]
----
quarkus.neo4j.uri=bolt://localhost:7687
quarkus.neo4j.authentication.username=neo4j
quarkus.neo4j.authentication.password=secret
----

=== Running

[source,console]
----
./mvnw quarkus:dev
----

=== Create docker images

(Extension `container-image-docker` must be provided once, via `./mvnw quarkus:add-extension -Dextensions="container-image-docker"`).

[source,console]
----
./mvnw clean package -Dquarkus.container-image.build=true
----

=== Create native images

[source,console]
----
# For your current system, GraalVM 11 is required
./mvnw clean package -Pnative
# As a native docker image
./mvnw package -Pnative -Dquarkus.native.container-build=true -Dquarkus.container-image.build=true
----

Quarkus offers `io.quarkus.runtime.annotations.RegisterForReflection` for classes that needs to be included in the image and require reflection based access.

=== Health

Health infrastructure provided with Quarkus Smallrye Health (`io.quarkus:quarkus-smallrye-health`), *Neo4j included ootb*.
All paths can be easily configured (health separate from liveness and readiness).

Format of the individual Neo4j status:

[source,bash]
.Request
----
$ curl 'http://localhost:8080/management/health' -i -X GET
----

[source,json]
----
{
  "status": "UP",
  "checks": [
    {
      "name": "Neo4j connection health check",
      "status": "UP",
      "data": {
        "server": "Neo4j/4.1.0@localhost:7687",
        "database": "neo4j"
      }
    }
  ]
}
----

== Spring

* ✅ Automatic setup of the Neo4j driver
* ✅ Officially supported Data Mapping framework available (SDN 6 for current, SDN5+OGM for older version)
* ✅ Built-in dev-mode with reload / restart feature
* ✅ Dedicated support for optimized docker images
* ✅ Reactive Streams: https://projectreactor.io[Project Reactor]
* ⚠️ GraalVM native compilation (Currently in beta, not part of a standard setup)
* ✅ Health (Liveness, Readiness and detailed status)

Demo projects provided:

* spring-plain-imperative
* spring-plain-reactive
* spring-data-imperative
* spring-data-reactive

Created via: https://start.spring.io, version tested: *2.4.0*.

=== Configuration of the Neo4j Java Driver

Full support of all official 4.1.x config options under the namespace `spring.neo4j.*`. 
Basic setup:

[source,properties]
----
spring.neo4j.uri=bolt://localhost:7687
spring.neo4j.authentication.username=neo4j
spring.neo4j.authentication.password=secret
----

=== Running

[source,console]
----
./mvnw spring-boot:run
----

=== Create docker images

[source,console]
----
./mvnw -DskipTests clean spring-boot:build-image
----

=== Create native images

Not possible ootb at the moment.

=== Health

Health infrastructure provided with Spring Boot Actuator (`org.springframework.boot:spring-boot-starter-actuator`), *Neo4j included ootb*.

NOTE: Path to individual endpoints for `liveness` and `readiness` seems to be changeable with
`management.endpoint.health.group.live.include=livenessState`, but that feels not very intuitive.

Format of the individual Neo4j status:

[source,bash]
.Request
----
$ curl 'http://localhost:8080/management/health' -i -X GET
----

[source,json]
----
{
  "status": "UP",
  "components": {
    "neo4j": {
      "status": "UP",
      "details": {
        "server": "Neo4j/4.1.0@localhost:7687",
        "edition": "enterprise",
        "database": "neo4j"
      }
    }
  }
}
----

== TCK

I have created a TCK - basically a glorified end-to-end-test - that brings up each application and ensure it's expected behaviour.
You need bash, Docker and JDK 15 to run it:

[source,console]
----
cd tck
./run.sh
----

It will bring up a Neo4j docker instance and take each project, build a docker image, start it and than executes a couple of requests against it.
The script is tested currently only under macOS.

== Size comparision

The size of the Docker images generated by the official instructions, chosing the path of the least resistance (or effort)

```
neo4j-from-the-jvm/helidon-se-reactive-native   33.1MB
neo4j-from-the-jvm/quarkus-imperative-native    164MB
neo4j-from-the-jvm/quarkus-reactive-native      166MB
neo4j-from-the-jvm/helidon-se-reactive          215MB
neo4j-from-the-jvm/spring-plain-imperative      282MB
neo4j-from-the-jvm/spring-plain-reactive        284MB
neo4j-from-the-jvm/spring-data-imperative       284MB
neo4j-from-the-jvm/spring-data-reactive         287MB
neo4j-from-the-jvm/micronaut-reactive           359MB
neo4j-from-the-jvm/quarkus-imperative           539MB
neo4j-from-the-jvm/quarkus-reactive             541MB
neo4j-from-the-jvm/quarkus-ogm                  542MB
```